
@misc{noauthor_reviewing_nodate,
	title = {Reviewing proposed changes in a pull request},
	url = {https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request},
	abstract = {In a pull request, you can review and discuss commits, changed files, and the differences (or "diff") between the files in the base and compare branches.},
	language = {en},
	urldate = {2025-03-08},
	journal = {GitHub Docs},
}

@misc{noauthor_merging_nodate,
	title = {Merging a pull request},
	url = {https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request},
	abstract = {Merge a pull request into the upstream branch when work is completed. Anyone with push access to the repository can complete the merge.},
	language = {en},
	urldate = {2025-03-08},
	journal = {GitHub Docs},
}

@misc{noauthor_closing_nodate,
	title = {Closing a pull request},
	url = {https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/closing-a-pull-request},
	abstract = {You may choose to close a pull request without merging it into the upstream branch. This can be handy if the changes proposed in the branch are no longer needed, or if another solution has been proposed in another branch.},
	language = {en},
	urldate = {2025-03-08},
	journal = {GitHub Docs},
}

@misc{noauthor_approving_nodate,
	title = {Approving a pull request with required reviews},
	url = {https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/approving-a-pull-request-with-required-reviews},
	abstract = {If your repository requires reviews, pull requests must have a specific number of approving reviews from people with write or admin permissions in the repository before they can be merged.},
	language = {en},
	urldate = {2025-03-08},
	journal = {GitHub Docs},
}

@misc{noauthor_about_nodate,
	title = {About pull requests},
	url = {https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests},
	abstract = {Learn about pull requests and draft pull requests on GitHub. Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.},
	language = {en},
	urldate = {2025-03-09},
	journal = {GitHub Docs},
}

@inproceedings{coutinho_looks_2024,
	address = {Salerno Italy},
	title = {"{Looks} {Good} {To} {Me} ;-)": {Assessing} {Sentiment} {Analysis} {Tools} for {Pull} {Request} {Discussions}},
	isbn = {979-8-4007-1701-7},
	shorttitle = {"{Looks} {Good} {To} {Me} ;-)"},
	url = {https://dl.acm.org/doi/10.1145/3661167.3661189},
	doi = {10.1145/3661167.3661189},
	language = {en},
	urldate = {2025-03-09},
	booktitle = {Proceedings of the 28th {International} {Conference} on {Evaluation} and {Assessment} in {Software} {Engineering}},
	publisher = {ACM},
	author = {Coutinho, Daniel and Cito, Luisa and Lima, Maria Vitória and Arantes, Beatriz and Alves Pereira, Juliana and Arriel, Johny and Godinho, João and Martins, Vinicius and Libório, Paulo Vítor C. F. and Leite, Leonardo and Garcia, Alessandro and Assunção, Wesley K. G. and Steinmacher, Igor and Baffa, Augusto and Fonseca, Baldoino},
	month = jun,
	year = {2024},
	pages = {211--221},
}

@misc{zack_git_2018,
	title = {A {Git} {Origin} {Story} {\textbar} {Linux} {Journal}},
	url = {https://www.linuxjournal.com/content/git-origin-story},
	abstract = {A look at Linux kernel developers' various revision control solutions through the years, Linus Torvalds' decision to use BitKeeper and the controversy that followed, and how Git came to be created.},
	language = {en},
	urldate = {2025-03-08},
	author = {Zack, Brown},
	month = jul,
	year = {2018},
}

@misc{noauthor_informationen_2025,
	title = {Informationen zu {Git} - {GitHub}-{Dokumentation}},
	url = {https://docs.github.com/de/get-started/using-git/about-git},
	abstract = {Learn about the version control system, Git, and how it works with GitHub.},
	language = {de},
	urldate = {2025-03-08},
	month = mar,
	year = {2025},
}

@inproceedings{bernardo_studying_2018,
	address = {Gothenburg Sweden},
	title = {Studying the impact of adopting continuous integration on the delivery time of pull requests},
	isbn = {978-1-4503-5716-6},
	url = {https://dl.acm.org/doi/10.1145/3196398.3196421},
	doi = {10.1145/3196398.3196421},
	abstract = {Continuous Integration (CI) is a software development practice that leads developers to integrate their work more frequently. Software projects have broadly adopted CI to ship new releases more frequently and to improve code integration. The adoption of CI is motivated by the allure of delivering new functionalities more quickly. However, there is little empirical evidence to support such a claim. Through the analysis of 162,653 pull requests (PRs) of 87 GitHub projects that are implemented in 5 different programming languages, we empirically investigate the impact of adopting CI on the time to deliver merged PRs. Surprisingly, only 51.3\% of the projects deliver merged PRs more quickly after adopting CI. We also observe that the large increase of PR submissions after CI is a key reason as to why projects deliver PRs more slowly after adopting CI. To investigate the factors that are related to the time-to-delivery of merged PRs, we train regression models that obtain sound median R-squares of 0.64-0.67. Finally, a deeper analysis of our models indicates that, before the adoption of CI, the integration-load of the development team, i.e., the number of submitted PRs competing for being merged, is the most impactful metric on the time to deliver merged PRs before CI. Our models also reveal that PRs that are merged more recently in a release cycle experience a slower delivery time.},
	language = {en},
	urldate = {2025-03-07},
	booktitle = {Proceedings of the 15th {International} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Bernardo, João Helis and Da Costa, Daniel Alencar and Kulesza, Uirá},
	month = may,
	year = {2018},
	pages = {131--141},
}

@inproceedings{kononenko_code_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {Code review quality: how developers see it},
	isbn = {978-1-4503-3900-1},
	shorttitle = {Code review quality},
	url = {https://dl.acm.org/doi/10.1145/2884781.2884840},
	doi = {10.1145/2884781.2884840},
	abstract = {In a large, long-lived project, an effective code review process is key to ensuring the long-term quality of the code base. In this work, we study code review practices of a large, open source project, and we investigate how the developers themselves perceive code review quality. We present a qualitative study that summarizes the results from a survey of 88 Mozilla core developers. The results provide developer insights into how they define review quality, what factors contribute to how they evaluate submitted code, and what challenges they face when performing review tasks. We found that the review quality is primarily associated with the thoroughness of the feedback, the reviewer's familiarity with the code, and the perceived quality of the code itself. Also, we found that while different factors are perceived to contribute to the review quality, reviewers often find it difficult to keep their technical skills up-to-date, manage personal priorities, and mitigate context switching.},
	urldate = {2025-03-07},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Kononenko, Oleksii and Baysal, Olga and Godfrey, Michael W.},
	year = {2016},
	pages = {1028--1038},
}

@book{west_temporal_2023,
	title = {The temporal side of pull request acceptance},
	url = {https://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-324020},
	abstract = {The contemporary way of contributing to open-source software is through online platforms. GitHub is the most widely used platform for this purpose. On GitHub, users can suggest improvements to proj ...},
	language = {eng},
	urldate = {2025-03-07},
	author = {West, Balthazar},
	year = {2023},
}

@inproceedings{tsay_influence_2014,
	address = {New York, NY, USA},
	series = {{ICSE} 2014},
	title = {Influence of social and technical factors for evaluating contribution in {GitHub}},
	isbn = {978-1-4503-2756-5},
	url = {https://dl.acm.org/doi/10.1145/2568225.2568315},
	doi = {10.1145/2568225.2568315},
	abstract = {Open source software is commonly portrayed as a meritocracy, where decisions are based solely on their technical merit. However, literature on open source suggests a complex social structure underlying the meritocracy. Social work environments such as GitHub make the relationships between users and between users and work artifacts transparent. This transparency enables developers to better use information such as technical value and social connections when making work decisions. We present a study on open source software contribution in GitHub that focuses on the task of evaluating pull requests, which are one of the primary methods for contributing code in GitHub. We analyzed the association of various technical and social measures with the likelihood of contribution acceptance. We found that project managers made use of information signaling both good technical contribution practices for a pull request and the strength of the social connection between the submitter and project manager when evaluating pull requests. Pull requests with many comments were much less likely to be accepted, moderated by the submitter's prior interaction in the project. Well-established projects were more conservative in accepting pull requests. These findings provide evidence that developers use both technical and social information when evaluating potential contributions to open source software projects.},
	urldate = {2025-03-07},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Tsay, Jason and Dabbish, Laura and Herbsleb, James},
	year = {2014},
	pages = {356--366},
}

@inproceedings{zhang_how_2018,
	title = {How do {Multiple} {Pull} {Requests} {Change} the {Same} {Code}: {A} {Study} of {Competing} {Pull} {Requests} in {GitHub}},
	shorttitle = {How do {Multiple} {Pull} {Requests} {Change} the {Same} {Code}},
	url = {https://ieeexplore.ieee.org/document/8530032},
	doi = {10.1109/ICSME.2018.00032},
	abstract = {GitHub is a widely used collaborative platform for global software development. A pull request plays an important role in bridging code changes with version controlling. Developers can freely and parallelly submit pull requests to base branches and wait for the merge of their contributions. However, several developers may submit pull requests to edit the same lines of code; such pull requests result in a latent collaborative conflict. We refer such pull requests that tend to change the same lines and remain open during an overlapping time period to as competing pull requests. In this paper, we conduct a study on 9,476 competing pull requests from 60 Java repositories in GitHub. The data are collected by mining pull requests that are submitted in 2017 from top Java projects with the most forks. We explore how multiple pull requests change the same code via answering four research questions, including the distribution of competing pull requests, the involved developers, the changed lines of code, and the impact on pull request integration. Our study shows that there indeed exist competing pull requests in GitHub: in 45 out of 60 repositories, over 31\% of pull requests belong to competing pull requests; 20 repositories have more than 100 groups of competing pull requests, each of which is submitted by over five developers; 42 repositories have over 10\% of competing pull requests with over 10 same lines of code. Meanwhile, we observe that attributes of competing pull requests do not have strong impacts on pull request integration, comparing with other types of pull requests. Our study provides a preliminary analysis for further research that aims to detect and eliminate conflicts among competing pull requests.},
	urldate = {2025-03-07},
	booktitle = {2018 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	author = {Zhang, Xin and Chen, Yang and Gu, Yongfeng and Zou, Weiqin and Xie, Xiaoyuan and Jia, Xiangyang and Xuan, Jifeng},
	month = sep,
	year = {2018},
	note = {ISSN: 2576-3148},
	keywords = {Collaboration, Control systems, Correlation, Data mining, GitHub, Java, Merging, Pull requests, Software, collaborative development, merge conflict},
	pages = {228--239},
}

@inproceedings{tao_writing_2014,
	title = {Writing {Acceptable} {Patches}: {An} {Empirical} {Study} of {Open} {Source} {Project} {Patches}},
	shorttitle = {Writing {Acceptable} {Patches}},
	url = {https://ieeexplore.ieee.org/document/6976093},
	doi = {10.1109/ICSME.2014.49},
	abstract = {Software developers submit patches to handle tens or even hundreds of bugs reported daily. However, not all submitted patches can be directly integrated into the code base, since they might not pass patch review that is adopted in most software projects. As the result of patch review, incoming patches can be rejected or asked for resubmission after improvement. Both scenarios interrupt the workflow of patch writers and reviewers, increase their workload, and potentially delay the general development process. In this paper, we aim to help developers write acceptable patches to avoid patch rejection and resubmission. To this end, we derive a comprehensive list of patch rejection reasons from a manual inspection of 300 rejected Eclipse and Mozilla patches, a large-scale online survey of Eclipse and Mozilla developers, and the literature. We also investigate which patch-rejection reasons are more decisive and which are difficult to judge from the perspective of patch reviewers. Our findings include 1) suboptimal solution and incomplete fix are the most frequent patch-rejection reasons 2) whether a patch introduces new bugs is very important yet very difficult to judge 3) reviewers reject a large patch not solely because of its size, but mainly because of the underlying reasons that induce its large size, such as the involvement of unnecessary changes 4) reviewers consider certain problems to be much more destructive than patch writers expect, such as the inconsistency of documentation in a patch and 5) bad timing of patch submission and a lack of communication with team members can also result in a negative patch review.},
	urldate = {2025-03-07},
	booktitle = {2014 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution}},
	author = {Tao, Yida and Han, Donggyun and Kim, Sunghun},
	month = sep,
	year = {2014},
	note = {ISSN: 1063-6773},
	keywords = {Computer bugs, Documentation, Encoding, Guidelines, Inspection, Manuals, empirical study, patch},
	pages = {271--280},
}

@inproceedings{gousios_exploratory_2014,
	address = {New York, NY, USA},
	series = {{ICSE} 2014},
	title = {An exploratory study of the pull-based software development model},
	isbn = {978-1-4503-2756-5},
	url = {https://dl.acm.org/doi/10.1145/2568225.2568260},
	doi = {10.1145/2568225.2568260},
	abstract = {The advent of distributed version control systems has led to the development of a new paradigm for distributed software development; instead of pushing changes to a central repository, developers pull them from other repositories and merge them locally. Various code hosting sites, notably Github, have tapped on the opportunity to facilitate pull-based development by offering workflow support tools, such as code reviewing systems and integrated issue trackers. In this work, we explore how pull-based software development works, first on the GHTorrent corpus and then on a carefully selected sample of 291 projects. We find that the pull request model offers fast turnaround, increased opportunities for community engagement and decreased time to incorporate contributions. We show that a relatively small number of factors affect both the decision to merge a pull request and the time to process it. We also examine the reasons for pull request rejection and find that technical ones are only a small minority.},
	urldate = {2025-03-07},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Gousios, Georgios and Pinzger, Martin and Deursen, Arie van},
	year = {2014},
	pages = {345--355},
}

@article{zhang_pull_2023,
	title = {Pull {Request} {Decisions} {Explained}: {An} {Empirical} {Overview}},
	volume = {49},
	copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
	issn = {0098-5589, 1939-3520, 2326-3881},
	shorttitle = {Pull {Request} {Decisions} {Explained}},
	url = {https://ieeexplore.ieee.org/document/9749844/},
	doi = {10.1109/TSE.2022.3165056},
	abstract = {Context: The pull-based development model is widely used in open source projects, leading to the emergence of trends in distributed software development. One aspect that has garnered signiﬁcant attention concerning pull request decisions is the identiﬁcation of explanatory factors. Objective: This study builds on a decade of research on pull request decisions and provides further insights. We empirically investigate how factors inﬂuence pull request decisions and the scenarios that change the inﬂuence of such factors. Method: We identify factors inﬂuencing pull request decisions on GitHub through a systematic literature review and infer them by mining archival data. We collect a total of 3,347,937 pull requests with 95 features from 11,230 diverse projects on GitHub. Using these data, we explore the relations among the factors and build mixed effects logistic regression models to empirically explain pull request decisions. Results: Our study shows that a small number of factors explain pull request decisions, with that concerning whether the integrator is the same as or different from the submitter being the most important factor. We also note that the inﬂuence of factors on pull request decisions change with a change in context; e.g., the area hotness of pull request is important only in the early stage of project development, however it becomes unimportant for pull request decisions as projects become mature.},
	language = {en},
	number = {2},
	urldate = {2025-03-06},
	journal = {IEEE Transactions on Software Engineering},
	author = {Zhang, Xunhui and Yu, Yue and Gousios, Georgios and Rastogi, Ayushi},
	month = feb,
	year = {2023},
	pages = {849--871},
}

@inproceedings{hasan_understanding_2023,
	title = {Understanding the {Time} to {First} {Response} in {GitHub} {Pull} {Requests}},
	url = {https://ieeexplore.ieee.org/document/10173964},
	doi = {10.1109/MSR59073.2023.00015},
	abstract = {The pull-based development is widely adopted in modern open-source software (OSS) projects, where developers propose changes to the codebase by submitting a pull request (PR). However, due to many reasons, PRs in OSS projects frequently experience delays across their lifespan, including prolonged waiting times for the first response. Such delays may significantly impact the efficiency and productivity of the development process, as well as the retention of new contributors as long-term contributors.In this paper, we conduct an exploratory study on the time-to-first-response for PRs by analyzing 111,094 closed PRs from ten popular OSS projects on GitHub. We find that bots frequently generate the first response in a PR, and significant differences exist in the timing of bot-generated versus human-generated first responses. We then perform an empirical study to examine the characteristics of bot- and human-generated first responses, including their relationship with the PR’s lifetime. Our results suggest that the presence of bots is an important factor contributing to the time-to-first-response in the pull-based development paradigm, and hence should be separately analyzed from human responses. We also report the characteristics of PRs that are more likely to experience long waiting for the first human-generated response. Our findings have practical implications for newcomers to understand the factors contributing to delays in their PRs.},
	urldate = {2025-03-06},
	booktitle = {2023 {IEEE}/{ACM} 20th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
	author = {Hasan, Kazi Amit and Macedo, Marcos and Tian, Yuan and Adams, Bram and Ding, Steven},
	month = may,
	year = {2023},
	note = {ISSN: 2574-3864},
	keywords = {Chatbots, Data mining, Delays, Focusing, Open source software, Productivity, Time factors, code review, fine-grained analysis, first response, latency analysis, pull request},
	pages = {1--11},
}

@inproceedings{yu_wait_2015,
	title = {Wait for {It}: {Determinants} of {Pull} {Request} {Evaluation} {Latency} on {GitHub}},
	shorttitle = {Wait for {It}},
	url = {https://ieeexplore.ieee.org/document/7180096},
	doi = {10.1109/MSR.2015.42},
	abstract = {The pull-based development model, enabled by git and popularised by collaborative coding platforms like Bit Bucket, Gitorius, and GitHub, is widely used in distributed software teams. While this model lowers the barrier to entry for potential contributors (since anyone can submit pull requests to any repository), it also increases the burden on integrators (i.e., Members of a project's core team, responsible for evaluating the proposed changes and integrating them into the main development line), who struggle to keep up with the volume of incoming pull requests. In this paper we report on a quantitative study that tries to resolve which factors affect pull request evaluation latency in GitHub. Using regression modeling on data extracted from a sample of GitHub projects using the Travis-CI continuous integration service, we find that latency is a complex issue, requiring many independent variables to explain adequately.},
	urldate = {2025-03-06},
	booktitle = {2015 {IEEE}/{ACM} 12th {Working} {Conference} on {Mining} {Software} {Repositories}},
	author = {Yu, Yue and Wang, Huaimin and Filkov, Vladimir and Devanbu, Premkumar and Vasilescu, Bogdan},
	month = may,
	year = {2015},
	note = {ISSN: 2160-1860},
	keywords = {Automatic testing, Complexity theory, Computational modeling, Data mining, Software engineering, Software quality},
	pages = {367--371},
}

@inproceedings{kuhejda_pull_2023,
	title = {Pull {Requests} {Acceptance}: {A} {Study} {Across} {Programming} {Languages}},
	shorttitle = {Pull {Requests} {Acceptance}},
	url = {https://ieeexplore.ieee.org/document/10371500},
	doi = {10.1109/SEAA60479.2023.00064},
	abstract = {Context: The pull-based development is a modern way to support distributed software development, helping to produce high-quality software with increased involvement from the software development community. Objectives: We investigate the effect of source code quality on Pull Request (PR) acceptance in different programming languages, looking at the quality flaws that can be more relevant. Method: We mine software repositories to analyze over 40K PRs from 100 open-source projects in five different programming languages: Python, Java, Kotlin, Haskell, and C/C++. The code quality of the individual PRs was evaluated using static code analysis. Quality flaws were inputted into classification models to predict PRs acceptance and evaluate the fitting. Results: There is a low impact of code quality on PRs acceptance. No major quality flaws can be used to predict reliably PRs acceptance. Conclusion: Source code quality plays a marginal role in accepting PRs in the analyzed projects. Additional factors might impact the acceptance of PRs, such as the reputation and popularity of the submitters.},
	urldate = {2025-03-06},
	booktitle = {2023 49th {Euromicro} {Conference} on {Software} {Engineering} and {Advanced} {Applications} ({SEAA})},
	author = {Kuhejda, Ondřej and Rossi, Bruno},
	month = sep,
	year = {2023},
	note = {ISSN: 2376-9521},
	keywords = {Codes, Fitting, Java, Mining Software Repositories, Predictive models, Pull Requests, Reliability, Software, Source Code Quality, Source coding, Static Code Analysis},
	pages = {378--385},
}

@inproceedings{kudrjavets_small_2022,
	title = {Do {Small} {Code} {Changes} {Merge} {Faster}? {A} {Multi}-{Language} {Empirical} {Investigation}},
	shorttitle = {Do {Small} {Code} {Changes} {Merge} {Faster}?},
	url = {http://arxiv.org/abs/2203.05045},
	doi = {10.1145/3524842.3528448},
	abstract = {Code velocity, or the speed with which code changes are integrated into a production environment, plays a crucial role in Continuous Integration and Continuous Deployment. Many studies report factors influencing code velocity. However, solutions to increase code velocity are unclear. Meanwhile, the industry continues to issue guidelines on "ideal" code change size, believing it increases code velocity despite lacking evidence validating the practice. Surprisingly, this fundamental question has not been studied to date. This study investigates the practicality of improving code velocity by optimizing pull request size and composition (ratio of insertions, deletions, and modifications). We start with a hypothesis that a moderate correlation exists between pull request size and time-to-merge. We selected 100 most popular, actively developed projects from 10 programming languages on GitHub. We analyzed our dataset of 845,316 pull requests by size, composition, and context to explore its relationship to time-to-merge - a proxy to measure code velocity. Our study shows that pull request size and composition do not relate to time-to-merge. Regardless of the contextual factors that can influence pull request size or composition (e.g., programming language), the observation holds. Pull request data from two other platforms: Gerrit and Phabricator (401,790 code reviews) confirms the lack of relationship. This negative result as in "... eliminate useless hypotheses ..." challenges a widespread belief by showing that small code changes do not merge faster to increase code velocity.},
	urldate = {2025-03-06},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Mining} {Software} {Repositories}},
	author = {Kudrjavets, Gunnar and Nagappan, Nachiappan and Rastogi, Ayushi},
	month = may,
	year = {2022},
	note = {arXiv:2203.05045 [cs]},
	keywords = {Computer Science - Software Engineering},
	pages = {537--548},
}
